# 汉诺塔与递归

 一定<u>***不要***</u>试图跟踪**大型递归**的过程！ 要写出递归，关键就是找出递归的**递归方程式**： 也就是说，要完成最后一步，那么最后一步的前一步要做什么。

## 关于递归

- 在求f(n, other variables)的时候，你就**<u>*默认*</u>**`f(n -1, other variables)`已经被求出来了——至于怎么求的，这个是计算机通过回溯求出来的。

  PS:这里用到了一种叫做栈(stack)的先进后出的数据结构，所以递归输出的答案一般是自下而上的。

- 递归和**二叉树**是密切相关的。可以尝试通过二叉树的数据结构来理解递归是如何将一个问题拆分成若干子问题，求解再回溯的。这里可以参考以下快速排序(QuickSort)的过程（快速排序的核心思想是**分治**，分治即分而治之，通过递归将原问题分解为若干容易求解的子问题，再通过递归将这些子问题联系起来并向二叉树的上层回溯，最终求解出原问题）


- 递归的关键有两个：

  - 递归的结束条件（不写会死循环，TLE）
  - 递归最后一层和其他有关系的层的关系怎样用非递归函数来表达

  比如：斐波纳契亚数列：当n==1和n==2的时候`f(n)=1`，这就是递归的终止条件。给了终止条件，计算机才能进行求解子问题并回溯，最终求出`f(n)`

## 汉诺塔

对于这个汉诺塔问题，在写递归时，我们只需要确定两个条件：

1. 递归何时结束？
2. 递归的核心公式是什么？
   1. 怎样将n个盘子全部移动到C柱上？
   2. 若使n个盘子全部移动到C柱上，上一步应该做什么？

> 汉诺塔：
> 汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？

下面我们来写递归函数：

递归函数怎么写呢?

我们先来想一下我们人类应该怎样操作吧。

我们每次操作都会这样问自己：我们需要将哪个柱子上的多少个盘子通过哪个柱子移动到哪个柱子上呢？

我们必须也只能用这么几个参数：

需要移动的盘子的总数`n`，3个柱子`x, y, z`，所以定义函数：

```python
def hanoi(n, x, y, z):
```

其中，n代表盘子总数，x，y，z代表柱子

`hanoi(n, x, y, z)`的意思就是：将`n`个在`x`柱子上的盘子<u>***通过`y`***</u>这个柱子移动到`z`这个柱子上。

那不就完了！

`hanoi(n, 'X', 'Y', 'Z')`就是这道问题的答案！

那么这一步的前一步是什么？

记住了，在求解`f(n, other variables)`的时候，***我们直接默认`f(n - 1, other variables)`已经完了就可以了！***

> 我们将n-1个盘子当作一个整体：这就是类似于分治求解子问题的思想
>

那么：

- 前一步也就是`f(n-1, other variables)`显然是先将`n-1` 个在A柱子上的盘子通过C柱移动到B柱上`(n-1)(x)  --z-->  y`，即`hanoi(n-1, x, z, y)`
- 再将在A柱子上的编号为n的盘子移动到C柱上`x --> z`，即`print(x, '-->', z)`
- 再将B柱子上的n-1个盘子通过A柱移动到C柱上`(n-1)(y) --x--> z`，即`hanoi(n-1, y, x, z)`

完整代码如下：

```python
def hanoi(n, x, y, z):
    if n == 1:
        print(x, '-->', z)
    else:
        # 将第n-1个盘子从x移动到y
        hanoi(n-1, x, z, y)  
        # 将第n个盘子移动到z
        print(x, '-->', z)
        # 将y上的n-1个盘子移动到z上
        hanoi(n-1, y, x, z)
```



